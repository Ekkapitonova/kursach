/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package kursovoi_proect_0.pkg1;

/**
 *
 * @author Екатерина
 */
public class Sort {
    static void reheap (int a[], int length, int i) throws Exception {
		
		//С этим родителем ещё не разобрались
		boolean done = false;
		
		//Запоминаем отдельно родителя 
		//и смотрим на его потомка слева
		int T = a[i];
		int parent = i;
		int child = 2 * (i + 1) - 1;
		
		//Просматриваем потомков, а также потомков потомков
		//и сравниваем их с родителем (если что - передвигаем потомков влево)
		//Цикл продолжается пока не выпадем за пределы массива
		//или пока не обменяем какого-нибудь потомка на родителя.		
		while ((child < length) && (!done)) {
			
			//Если правый потомок в пределах массива
			if (child < length - 1) {
				//То из левого и правого потомка выбираем наименьшего
				if (a[child] >= a[child + 1]) {
					child += 1;
				}
			}
			
			//Родитель меньше потомков?
			if (T < a[child]) {
				
				//Тогда с этим родителем и его потомками разобрались
				done = true;
			
			//Родитель НЕ меньше чем наименьший из его потомков.
			//Перемещаем потомка на место родителя
			//и с родителем в цикле сравниваем уже потомков этого потомка			
			} else {			

				a[parent] = a[child];
				parent = child;
				child = 2 * (parent + 1) - 1;
				
			}
		}
		
		//Родитель, с которого всё начиналось
		//передвигается ближе к концу массива
		//(или остаётся на месте если не повезло)
		a[parent] = T;
		
    }

	//С помошью неполной НЕВОЗРАСТАЮЩЕЙ кучи 
	//мелкие элементы закидываем поближе к началу массива
    static void invreheap (int a[], int length, int i) throws Exception {
	
		//С этим родителем ещё не разобрались
		boolean done = false;

		//Запоминаем отдельно родителя 
		//и смотрим на его потомка слева
		int T = a[length - 1 - i];
		int parent = i;
		int child = 2 * (i + 1) - 1;
		
		//Просматриваем потомков, а также потомков потомков
		//и сравниваем их с родителем (если что - передвигаем потомков)
		//Цикл продолжается пока не выпадем за пределы массива
		//или пока не обменяем какого-нибудь потомка на родителя.
		while ((child < length) && (!done)) {
			
			//Если левый потомок в пределах массива
			if (child < length - 1) {
				
				//То из левого и правого потомка выбираем наибольшего
				if (a[length - 1 - child] <= a[length - 1 - (child + 1)]) {
					child += 1;
				}
				
			}
			
			//Родитель больше потомков?
			if (T > a[length - 1 - child]) {
				
				//Тогда с этим родителем и его потомками разобрались
				done = true;
				
			} else {

				//Родитель НЕ больше чем наибольший из его потомков.
				//Перемещаем потомка на место родителя
				//и с родителем в цикле сравниваем уже потомков этого потомка	
				a[length - 1 - parent] = a[length - 1 - child];
				parent = child;
				child = 2 * (parent + 1) - 1;
				
			}
		}
		
		//Родитель, с которого всё начиналось
		//передвигается ближе к началу массива
		//(или остаётся на месте если не повезло)
		a[length - 1 - parent] = T;
		
    }

	//Основная процедура сортировки
    static void sort(int a[]) throws Exception {

		//Строим неубывающую кучу
		//Большие элементы из начала массива
		//закидываем поближе к концу
		for (int i = a.length-1; i >= 0; i--)
			reheap (a, a.length, i);
		
		//Строим невозрастающую кучу
		//Меньшие элементы из конца массива
		//закидываем поближе к началу
		for (int i = a.length - 1; i >= 0; i--)
			invreheap (a, a.length, i);
		
		//Массив ПОЧТИ упорядочен
		//Досортировываем вставками
		for (int j = 1; j < a.length; j++) {
			int T = a[j];
			int i = j - 1;
			while (i >= 0 && a[i] > T) {
				a[i + 1] = a[i];
				i -= 1;
			}
			a[i + 1] = T;
		}

    }
}
